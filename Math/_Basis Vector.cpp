/*
 * Problem it Solves: Comprehensive Linear Basis (Insert, Check, Max XOR, K-th smallest, Count < X).
 * Usage: Basis<int> B; B.insert(x); B.kth(k);
 * Input/Output: Integers.
 * Time Complexity: O(B) per operation.
 * Tweaks: Template T and B (bits).
 * Other Use Cases: XOR problems.
 * Warnings: kth(k) assumes distinct XOR sums generated by subsets (2^sz values). 1st is 0.
 */

#include <bits/stdc++.h>
using namespace std;

const int N = 3e5 + 9;
using ll = long long;

template<typename T = int, int B = 31> // TWEAK: Change T to long long and B to 63 if needed
struct Basis {
    T basis[B]; 
    int sz; // Number of linearly independent vectors

    void clear() {
        memset(basis, 0, sizeof basis);
        sz = 0;
    }
    Basis() {
        clear();
    }

    void insert(T x) {
        for (int i = B - 1; i >= 0; i--) {
            if (x >> i & 1) {
                if (basis[i]) x ^= basis[i];
                else {
                    basis[i] = x;
                    sz++;
                    break;
                }
            }
        }
    }

    // Is there any subset having xor = x
    bool can(T x) {
        for (int i = B - 1; i >= 0; i--) {
            x = min(x, x ^ basis[i]);
        }
        return x == 0;
    }

    // Max subset xor after xoring it with x
    T max_xor(T x = 0) {
        for (int i = B - 1; i >= 0; i--) {
            x = max(x, x ^ basis[i]);
        }
        return x;
    }

    // K-th smallest subset xor, 1st is 0
    // KEY: Reconstructs the number from the basis vectors as if they were bits.
    // Note: This implicitly assumes the basis is somewhat reduced or processes from MSB.
    // Since standard insertion puts `x` into highest possible `basis[i]`, `basis[i]` has `i-th` bit set.
    // This acts like a `1` at position `i`.
    T kth(T k) {
        if (k < 1 || k > ((T)1 << sz)) {
            return -1;
        }
        T x = 0;
        T cnt = ((T)1 << sz);
        for (int i = B - 1; i >= 0; i--) {
            if (basis[i]) {
                // Decide whether to include basis[i] based on k and current count
                if (k > (cnt >> 1)) {
                    // We need the upper half, so ensure i-th bit contributes 1 (relative to current x)
                    if (!(x >> i & 1)) {
                        x ^= basis[i];
                    }
                    k -= (cnt >> 1);
                } else {
                    // We need the lower half
                    if (x >> i & 1) {
                        x ^= basis[i];
                    }
                }
                cnt >>= 1;
            }
        }
        return x;
    }

    // Number of subsets having xor < x
    T count_lt(T x) {
        if (x < 0) return 0;
        T ans = 0;
        T cnt = ((T)1 << sz);
        T mask = 0;
        for (int i = B - 1; i >= 0; i--) {
            // at this stage, all prev > i th bits in mask and x are the same
            if (basis[i]) {
                if (x >> i & 1) {
                    ans += (cnt >> 1);
                    if (!(mask >> i & 1)) {
                        mask ^= basis[i];
                    }
                } else {
                    if (mask >> i & 1) {
                        mask ^= basis[i];
                    }
                }
                cnt >>= 1;
            } else {
                if ((x >> i & 1) != (mask >> i & 1)) {
                    if (x >> i & 1) {
                        return ans + cnt;
                    } else {
                        return ans;
                    }
                }
            }
        }
        return ans;
    }
};

void solve() {
    int q; cin >> q;
    Basis<int> B;
    while (q--) {
        int ty, k; cin >> ty >> k;
        if (ty == 1) B.insert(k);
        else cout << B.kth(k) << '\n';
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
